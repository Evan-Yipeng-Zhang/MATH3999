#include "algorithm.h"
#include <fstream>
#include <iostream>

void combineMSTAndMWPM(const std::string& mstPath, const std::string& mwpmPath, const std::string& combinedPath, std::unordered_map<int, int>& inverseMap) {
    Graph mstGraph = create_graph(mstPath);
    Graph mwpmGraph = create_graph(mwpmPath);

    // Apply inverse mapping to MWPM edges only
    for (auto& edge : mwpmGraph.edges) {
        std::get<1>(edge) = inverseMap.at(std::get<1>(edge)); // Re-map u vertex
        std::get<2>(edge) = inverseMap.at(std::get<2>(edge)); // Re-map v vertex
    }

    // Combine the edges from MST and mwpmGraph.edges
    mstGraph.edges.insert(mstGraph.edges.end(), mwpmGraph.edges.begin(), mwpmGraph.edges.end());
    mstGraph.E = mstGraph.edges.size();
    mstGraph.saveGraphToFile(combinedPath);
}

void runAlgorithm6(const std::string& inputFile, const std::string& outputFile) {
    std::string basePath = getExecutablePath();

    // Execute MST computation (e.g., with Algorithm 2 or 3)
    runAlgorithm2(inputFile, basePath + "\\mst");

    // Find odd degree vertices in MST
    Graph g = create_graph(basePath + "\\mst");
    std::vector<int> oddVertices = g.findOddDegreeVertices();

    // Prepare input for MWPM and compute MWPM
    std::unordered_map<int, int> vertexMap;
    for (int i = 0; i < oddVertices.size(); ++i) {
        vertexMap[oddVertices[i]] = i;
    }
    g = create_graph(inputFile);
    g.prepareMWPMInput(oddVertices, basePath + "\\mwpm_input", vertexMap);
    std::string blossomPath = readToolPath();
    std::string cmdMWPM = blossomPath + "/blossom4 -e " + basePath + "\\mwpm_input -w " + basePath + "\\mwpm_output";
    system(cmdMWPM.c_str());

    // Combine MST and MWPM into a multigraph
    std::unordered_map<int, int> inverseMap;
    for (const auto& pair : vertexMap) {
        inverseMap[pair.second] = pair.first;  // Create inverse mapping
    }
    combineMSTAndMWPM(basePath + "\\mst", basePath + "\\mwpm_output", basePath + "\\combined_graph", inverseMap);

    // Generate Eulerian tour from combined graph
    runAlgorithm1(basePath + "\\combined_graph", basePath + "\\eulerian_tour");

    // Convert Eulerian tour to Hamiltonian cycle
    g = create_graph(inputFile);
    Graph e = create_graph(basePath + "\\eulerian_tour");
    e.convertToHamiltonianCycle(g, outputFile);

    std::cout << "Hamiltonian cycle generated by algorithm 6 successfully." << std::endl;
}